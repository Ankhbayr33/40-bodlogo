Шийдэл:
Тохиромжтой арга бол BFS (Breadth-First Search) буюу өргөн цар хүрээтэй хайлт хийх юм. Учир нь бид хамгийн бага алхамаар очих замыг олох ёстой.

BFS арга:

Торон дээрээс эхэлж, эхний байрлалаас бүх боломжит хөдөлгөөнүүдийг хайна.

Хөдөлгөөн нь босоо болон хэвтээ чиглэлд хаалтнаас (X) урьдчилан хаагдаагүй хүртэлх бүх зайг хамарна.

Хөдөлгөөн бүрийг шинэ байрлал болгож үзэн, дараа нь тэндээс цааш үргэлжлүүлэн хайна.

Алхмын тоог зам дагуу хадгална.

Зорилтот байрлалд хүрэх үед тухайн алхмын тоог буцаана.

Кодыг хэрхэн бичсэн тухай:
Өгөгдлийг бэлтгэх:
grid нь торон дээрх мөр бүрийг агуулсан List<String> хэлбэртэй байна.
Эхлэл болон зорилтот байрлалыг startX, startY, goalX, goalY гэж өгсөн.

Хөдөлгөөний чиглэлүүдийг тодорхойлох:
Долоон босоо болон хэвтээ чиглэлд хөдөлж болно, тиймээс чиглэлүүдийг dx ба dy массивуудаар хадгална.

dx = {-1, 1, 0, 0} (доош, дээш, зүүн, баруун)

dy = {0, 0, -1, 1}

BFS хэрэглэх:

Хөдөлгөөн бүрийг BFS queue-д нэмнэ.

Байрлалд орж ирэх үед тухайн байрлалыг очсон байдал (visited) гэж тэмдэглэж, дахин орохгүй байхыг хангана.

Шалгах:

Өгөгдсөн байрлалд очиход steps буюу алхмын тоог буцаана.

Тайлбар:
BFS ашиглахдаа эхлээд эхний байрлалаа queue-д оруулж, алхмын тоог 0 гэж тэмдэглэнэ.

Дараа нь queue-аас нэг байрлал авч, бүх босоо болон хэвтээ чиглэл рүү гүйцэд гүйж очиж болох байрлалуудыг шалгана.

Шалгасан байрлал бүрийг алхмын тоог нэгээр нэмээд queue-д нэмдэг.

Ингэснээр хамгийн бага алхамаар зорилтот цэгт очих замыг олоно.

Хэрвээ зам байхгүй бол -1 буцаана.
![alt text](<Screenshot 2025-06-09 180417.png>)
